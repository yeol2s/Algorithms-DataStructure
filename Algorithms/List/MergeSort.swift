//
//  MergeSort.swift
//  Algorithms
//
//  Created by 유성열 on 7/2/24.
//
// MARK: - 병합 정렬(Merge Sort)
// MARK: 정렬 알고리즘으로 '분할 정복 알고리즘'의 하나이다. 배열을 분할하고 정렬된 부분 배열을 병합하여 전체 배열을 정렬한다. ('재귀'로 정렬하는 알고리즘)
// MARK: "해결하기 힘든 문제가 발생한다면 이걸 한 번에 해결하려고 하지 말고, 해결하기 쉬울 정도로 문제를 쪼갠 다음 하나씩 해결하자!"
// 조금 복잡한 알고리즘이지만 안정적인 정렬 알고리즘으로 최악의 경우에도 O(n log n)의 시간 복잡도를 보장.
/*
 * 병합 정렬의 과정
    1. 분할(Divide) : 배열을 절반으로 나누어 두 개의 부분 배열로 분할(배열을 재귀적으로 반으로 나누어 길이가 1이 될 때 까지 나눔)
    2. 정복(Conquer) : 각 부분 배열을 재귀적으로 병합 정렬을 적용하여 정렬(길이가 1인 배열은 이미 정렬된 상태이므로 그대로 반환)
    3. 병합(Merge) : 두 개의 정렬된 부분 배열을 하나의 정렬된 배열로 병합(merge 함수를 사용하여 두 정렬된 배열을 하나의 정렬된 배열로 병합)
 
1.초기 호출:
 - mergeSort(numbers)를 호출하면, numbers 배열이 mergeSort 함수의 인자로 전달

2.분할 과정:
 - numbers 배열의 길이는 8이므로, middleIndex는 4가 됨
 - 배열을 [64, 25, 12, 22]와 [11, 1, 5, 20]로 나눈다.
 - 이 두 부분 배열에 대해 다시 mergeSort를 재귀적으로 호출

3.재귀적 분할:
 - 각 부분 배열에 대해 같은 과정을 반복하여 배열의 길이가 1이 될 때까지 계속 나눔
 - 예를 들어, [64, 25, 12, 22]는 [64, 25]와 [12, 22]로, 다시 [64], [25], [12], [22]로 나눠짐
 
4.병합 과정:
 - 배열의 길이가 1이 되면, 재귀 호출이 종료되고 merge 함수가 호출
 - [64]와 [25]를 병합하여 [25, 64]가 됨
 - [12]와 [22]를 병합하여 [12, 22]가 됨
 - 이후, [25, 64]와 [12, 22]를 병합하여 [12, 22, 25, 64]가 됨
 
5.최종 병합:
 - 같은 과정을 오른쪽 부분 배열 [11, 1, 5, 20]에 대해 반복
 - 최종적으로 두 정렬된 부분 배열을 병합하여 전체 정렬된 배열 [1, 5, 11, 12, 20, 22, 25, 64]가 됨
 
*요약
 - mergeSort 함수는 재귀적으로 배열을 분할하고, 각 부분 배열을 정렬한 후 merge 함수를 사용하여 병합
 - merge 함수는 두 정렬된 배열을 비교하여 작은 값을 결과 배열에 추가하고, 남은 요소들을 결과 배열에 추가하는 역할
 - 재귀 호출과 병합 과정을 통해 전체 배열이 정렬.
 
 *병합정렬(mergeSort) 함수는 재귀적으로 배열을 반으로 나누고, 각 부분 배열을 정렬한 후 병합하는 과정을 반복하는데 이 과정에서 병합(merge) 함수가 계속 호출되어
 두 부분 배열을 비교하고 병합하여 하나의 정렬된 배열로 만들어 낸다.
 
*/

/*
 * 병합 정렬 과정 상세 내용
 
 1. 분할 단계
 
 ex) 배열 [64, 25, 12, 22, 11, 1, 5, 20]
 
 분할 단계에서는 주어진 배열을 계속해서 절반으로 나눔(재귀적으로)
    첫 번째 분할: [64, 25, 12, 22]와 [11, 1, 5, 20]
    두 번째 분할: [64, 25]와 [12, 22], [11, 1]과 [5, 20]
    세 번째 분할: [64], [25], [12], [22], [11], [1], [5], [20]
 이제 각각의 부분 배열은 길이가 1인 상태이며, 이는 이미 정렬된 상태

 2. 정복 단계 (mergeSort 함수가 재귀적으로 부분 배열을 정렬한 후 merge 함수를 호출하여 두 정렬된 부분 배열을 병합할 때 일어남)
 정복 단계에서는 분할된 부분 배열을 병합하여 정렬된 배열로 만듦(재귀적으로)
    첫 번째 병합: [64]와 [25]를 병합하여 [25, 64]로 만듦, [12]와 [22]를 병합하여 [12, 22]로 만듦
    두 번째 병합: [11]과 [1]을 병합하여 [1, 11]로 만듦, [5]와 [20]을 병합하여 [5, 20]로 만듦
    세 번째 병합: [25, 64]와 [12, 22]를 병합하여 [12, 22, 25, 64]로 만듦, [1, 11]과 [5, 20]을 병합하여 [1, 5, 11, 20]로 만듦
    최종 병합: [12, 22, 25, 64]와 [1, 5, 11, 20]을 병합하여 최종 정렬된 배열 [1, 5, 11, 12, 20, 22, 25, 64]을 만든다.
 
 3. 병합 과정
병합 과정은 두 정렬된 배열을 하나의 정렬된 배열로 합치는 과정
    merge 함수에서 두 정렬된 배열 'left' 'right'를 받아서, 두 배열의 요소들을 비교하고 작은 값 부터 'orderedArray'에 추가하고 남아있는 요소들을 'orderedArray'에 추가하여 반환한다.
 
 */



import Foundation

// 나누고
func mergeSort(_ array: [Int]) -> [Int] {
    
    // 배열의 길이가 1 이하면 이미 정렬된 상태이므로 반환(재귀 탈출 조건 -> 배열의 길이가 1이 될때까지 계속 나눈다.)
    guard array.count > 1 else {
        return array
    }
    
    // 배열을 반으로 나눔
    let middleIndex = array.count / 2 // 절반으로 나눔
    let leftArray = mergeSort(Array(array[0..<middleIndex])) // 재귀 (Array로 기존 배열의 범위를 반으로 나눈 새로운 배열을 생성해서 넣어줌)
    let rightArray = mergeSort(Array(array[middleIndex..<array.count]))
    
    // 두 정렬된 배열을 병합
    // MARK: * merge 함수는 mergeSort가 재귀적으로 동작한 후 배열의 길이가 1이 되어 반환된 후에 두 부분 배열을 병합하기 위해 merge 함수가 호출된다.
    return merge(leftArray, rightArray)
}

// (비교 연산 후)병합하고
func merge(_ left: [Int], _ right: [Int]) -> [Int] {
    var leftIndex = 0
    var rightIndex = 0
    var orderedArray: [Int] = [] // 결과 배열
    
    // 두 배열을 비교하여 작은 값을 결과 배열에 추가
    while leftIndex < left.count && rightIndex < right.count { // left, right 배열의 모든 요소를 다 처리할 때까지 반복
        // left와 right의 요소들을 비교하여 순서대로 결과 배열에 추가한다.(비교하여 작은 값을 추가 -> 추가한후 해당 Index를 1씩 증가)
        // 두 배열을 하나의 정렬된 배열로 병합하는 과정
        if left[leftIndex] < right[rightIndex] {
            orderedArray.append(left[leftIndex])
            leftIndex += 1
        } else {
            orderedArray.append(right[rightIndex])
            rightIndex += 1
        }
    }
    
    // 남아 있는 요소들을 결과 배열에 추가
    while leftIndex < left.count {
        orderedArray.append(left[leftIndex])
        leftIndex += 1
    }
    
    while rightIndex < right.count {
        orderedArray.append(right[rightIndex])
        rightIndex += 1
    }
    
    return orderedArray
}

/*
 * 단계별 동작
 배열 [64, 25, 12, 22, 11, 1, 5, 20]을 정렬

 1. 최초 호출:
    mergeSort([64, 25, 12, 22, 11, 1, 5, 20])
    배열을 두 부분으로 나눔: [64, 25, 12, 22]와 [11, 1, 5, 20]
 
 2. 재귀적 분할:
    -mergeSort([64, 25, 12, 22])를 호출
        [64, 25]와 [12, 22]로 나눔
        mergeSort([64, 25])를 호출
            [64]와 [25]로 나눔
            mergeSort([64])는 [64]를 반환
            mergeSort([25])는 [25]를 반환
            merge([64], [25])를 호출하여 [25, 64]를 만듦
        mergeSort([12, 22])를 호출
            [12]와 [22]로 나눔
            mergeSort([12])는 [12]를 반환
            mergeSort([22])는 [22]를 반환
            merge([12], [22])를 호출하여 [12, 22]를 만듦
        merge([25, 64], [12, 22])를 호출하여 [12, 22, 25, 64]를 만듦
 
    -mergeSort([11, 1, 5, 20])를 호출
        [11, 1]과 [5, 20]로 나눔
        mergeSort([11, 1])를 호출
            [11]과 [1]으로 나눔
            mergeSort([11])는 [11]을 반환
            mergeSort([1])는 [1]을 반환
            merge([11], [1])를 호출하여 [1, 11]을 만듦
        mergeSort([5, 20])를 호출
            [5]와 [20]으로 나눔
            mergeSort([5])는 [5]를 반환
            mergeSort([20])는 [20]을 반환
            merge([5], [20])를 호출하여 [5, 20]을 만듦
        merge([1, 11], [5, 20])를 호출하여 [1, 5, 11, 20]을 만듦
    -merge([12, 22, 25, 64], [1, 5, 11, 20])를 호출하여 최종적으로 [1, 5, 11, 12, 20, 22, 25, 64]을 만듦
 
 *병합 정렬의 재귀 호출과 병합 과정
 재귀 호출이 깊어지면서 가장 작은 단위로 분할되고, 재귀 호출이 완료되면서 병합 과정이 시작됨, 이 과정은 다음과 같이 동작

    1. 가장 작은 단위로 분할:
        - 각 재귀 호출은 배열을 두 부분으로 나누고, 배열의 길이가 1이 될 때까지 반복
 
    2.병합 시작:
        - 배열의 길이가 1이 되면, 이는 이미 정렬된 상태이므로 그대로 반환
        - 재귀 호출이 완료되면서, 각 재귀 호출의 merge 함수가 호출되어 두 부분 배열을 병합
        - 병합은 재귀 호출이 종료된 순서대로 차례로 진행
 */


// 병합 정렬의 전체 시간 복잡도는 O(n) 시간 복잡도를 가진 병합 과정이 log2(n) 단계만큼 반복되므로 O(n log n)이 된다.
// MARK: log2(n)은 '이진로그', 이진로그는 2를 base로 한 로그이다. log2(n)은 "2를 몇 번 곱해야 n이 되는가?"를 의미함. 'log2(8) = 3'은 길이가 8인 배열이 완전히 분할되어 더 이상 나눌 수 없는 1의 길이가 되기까지 3단계가 필요하다는 것! ('8 / 2 = 4' -> '4 / 2 = 2' -> '2 / 2 = 1' .... "길이가 8인 배열이 완전히 분할되어 더 이상 나눌 수 없는 1의 길이가 되기까지 3단계가 필요하다는 것)
/*
 * 병합 정렬 시간복잡도 정리
 1. 분할(Divide) 단계 :
 - 배열을 계속해서 반으로 나누는 단계
 - 배열이 완전히 분활될 때 까지의 단계 수는 log2(n) 단계
 - 예) 길이가 8인 배열은 8 -> 4 -> 2 -> 1 로 총 log2(8) = 3 단계로 나뉜다.
 
 2. 정복 및 병합 단계 :
 - 분할된 배열을 병합하면서 정렬
 - 각 단계에서 전체 배열을 처리하므로 O(n) 시간이 걸림
 
 결과적으로 병합 정렬은 O(n) * O(log n) = O(n log n) 시간
 */
