//
//  InsertionSort.swift
//  Algorithms
//
//  Created by 유성열 on 7/2/24.
//
// MARK: - 삽입 정렬(Insertion Sort)
// MARK: ('정렬된 영역', '정렬되지 않은 영역'으로 나뉜다.) 정렬되지 않은 영역에서 데이터를 하나씩 꺼내서 정렬된 영역내 적절한 위치에 '삽입'해서 정렬하는 알고리즘
// 삽입정렬은 정렬되지 않은 영역의 가장 앞에 있는 숫자를 하나씩 정렬된 영역의 적절한 위치에 '삽입'을 하며 정렬을 진행한다.
// 정렬되지 않은 영역의 첫번째 요소를 정렬된 영역의 가장 뒤에 있는 요소부터 역순으로 비교한다.(그리고 덮어 씀)
// 성능이 아쉬운 알고리즘으로 시간복잡도는 (이미 정렬된 배열)최선의 경우 - O(n), (역순으로 정렬된 배열)최악의 경우 - O(n2), 평균적으로는 - O(n2)
// 삽입 정렬은 요소들이 이미 대부분 정렬된 경우 매우 효율적으로 동작하고, 추가적인 메모리 사용없이 정렬할 수 있는 장점이 있다. 하지만 요소들이 역순으로 정렬된 경우에는 성능이 급격하게 저하될 수 있다.

/*
 1. 배열의 두 번째 요소부터 시작하여 현재 요소를 선택
 2. 선택된 현재 요소를 정렬된 부분 배열에 삽입하기 위해 정렬된 영역의 가장 뒤에 있는 요소부터 비교를 시작
 3. 현재 요소가 비교되는 요소보다 작으면, 비교되는 요소를 오른쪽으로 이동
 4. 위 과정을 반복하여 현재 요소가 삽입될 위치를 찾는다.
 5. 현재 요소를 그 위치에 삽입
 6. 정렬되지 않은 부분의 다음 요소를 선택하여 위 과정을 반복
 */

/*
 * 삽입 정렬의 과정 설명
 1. 초기 배열: [64, 25, 12, 22, 11]

 2. 첫 번째 반복 (i = 1):
 key = 25
 j = 0
 array[j] (64)와 key (25)를 비교
 64 > 25이므로 64를 오른쪽으로 이동
 j를 감소시켜 -1로 만듦
 array[j + 1]에 key (25)를 삽입
 결과 배열: [25, 64, 12, 22, 11]
 
 3. 두 번째 반복 (i = 2):
 key = 12
 j = 1
 array[j] (64)와 key (12)를 비교
 64 > 12이므로 64를 오른쪽으로 이동
 j를 감소시켜 0으로 만듦
 array[j] (25)와 key (12)를 비교
 25 > 12이므로 25를 오른쪽으로 이동
 j를 감소시켜 -1로 만듦
 array[j + 1]에 key (12)를 삽입
 결과 배열: [12, 25, 64, 22, 11]
 
 4. 세 번째 반복 (i = 3):
 key = 22
 j = 2
 array[j] (64)와 key (22)를 비교
 64 > 22이므로 64를 오른쪽으로 이동
 j를 감소시켜 1로 만듦
 array[j] (25)와 key (22)를 비교
 25 > 22이므로 25를 오른쪽으로 이동
 j를 감소시켜 0으로 만듦
 array[j] (12)와 key (22)를 비교
 12 < 22이므로 비교를 중단하고 key (22)를 array[j + 1]에 삽입
 결과 배열: [12, 22, 25, 64, 11]
 
 5. 네 번째 반복 (i = 4):
 key = 11
 j = 3
 array[j] (64)와 key (11)를 비교
 64 > 11이므로 64를 오른쪽으로 이동
 j를 감소시켜 2로 만듦
 array[j] (25)와 key (11)를 비교
 25 > 11이므로 25를 오른쪽으로 이동
 j를 감소시켜 1로 만듦
 array[j] (22)와 key (11)를 비교
 22 > 11이므로 22를 오른쪽으로 이동
 j를 감소시켜 0으로 만듦
 array[j] (12)와 key (11)를 비교
 12 > 11이므로 12를 오른쪽으로 이동
 j를 감소시켜 -1로 만듦
 array[j + 1]에 key (11)를 삽입
 
 결과 배열: [11, 12, 22, 25, 64]
 */



import Foundation

func insertionSort(_ array: inout [Int]) {
    
    // 배열 루프를 도는데 key에는 현재 요소가 들어간다.
    for i in 1..<array.count { // 배열의 두 번째 요소부터 시작
        let key = array[i] // 현재 요소를 key에 저장(각 단계에서 key는 정렬되지 않은 부분 배열의 첫 번째 요소를 나타냄(현재 요소))
        var j = i - 1 // 정렬된 부분의 마지막 Index
        
        // 정렬된 부분 배열에서 현재 요소(key)의 위치를 찾기 위한 비교
        while j >= 0 && array[j] > key { // (j는 계속 줄어들것이고) && 현재 요소가 비교되는 요소보다 작다면
            array[j + 1] = array[j] // 비교되는 요소를 오른쪽으로 이동
            j -= 1
        }
        // 현재 요소(key)를 올바른 위치에 삽입
        array[j + 1] = key
    }
}


// MARK: 위 루프에서 배열의 두 번째 요소부터 시작하는 이유는
/*
 (1) '첫 번째 요쇼는 자동으로 정렬되어 있다.(첫 번째 요소 하나만 있을 때는 비교할 다른 요소가 없기 때문에, 이미 정렬된 상태라고 봄)'
 (2) 두 번째 요소부터 시작하면 자연스럽게 정렬된 부분과 정렬되지 않은 부분으로 배열을 나눌 수 있다.
 ex) [64, 25, 12, 22, 11]을 예로 들자면..
 1. 초기 상태:
 정렬된 부분: [64]
 정렬되지 않은 부분: [25, 12, 22, 11]
 첫 번째 반복 (i = 1):
 
 2. 첫 번째 루프(i = 1)
 현재 요소는 25 (array[1])
 25를 정렬된 부분 [64]에 삽입
 정렬된 부분: [25, 64]
 정렬되지 않은 부분: [12, 22, 11]
 두 번째 반복 (i = 2):
 
 3. 두 번째 루프(i = 2)
 현재 요소는 12 (array[2])
 12를 정렬된 부분 [25, 64]에 삽입
 정렬된 부분: [12, 25, 64]
 정렬되지 않은 부분: [22, 11]
 세 번째 반복 (i = 3):
 
 4. 세 번째 루프(i = 3)
 현재 요소는 22 (array[3])
 22를 정렬된 부분 [12, 25, 64]에 삽입
 정렬된 부분: [12, 22, 25, 64]
 정렬되지 않은 부분: [11]
 네 번째 반복 (i = 4):
 
 5. 네 번째 루프(i = 4)
 현재 요소는 11 (array[4])
 11를 정렬된 부분 [12, 22, 25, 64]에 삽입
 정렬된 부분: [11, 12, 22, 25, 64]
 정렬되지 않은 부분: [] (없음)
 
 이 과정을 통해 배열 전체가 정렬
 
 */
