//
//  HashSearch.swift
//  Algorithms
//
//  Created by 유성열 on 7/15/24.
//
// MARK: - 해시 탐색(HashSearch)
// MARK: 해시 테이블(HashTable)(key-value 자료구조)을 사용하는 탐색 알고리즘으로 데이터를 매우 빠르게 검색, 삽입, 삭제 할 수 있음
// * 해시 테이블은 해시 함수를 사용하여 키를 특정 슬롯이나 버킷에 매핑한다.
// MARK: 키(key)-값(value) 쌍을 이용한 탐색 방법(해시 충돌을 관리해야 함) 빠른 검색, 삽입, 삭제가 필요한 경우 사용(키-값 쌍으로 데이터를 관리할 때 사용할 수 있음)
// 평균 시간 복잡도는 O(1) (매우 빠름), (충돌이 많아지면)최악의 경우 O(n)의 시간 복잡도. (해시 함수와 충돌 해결 방법에 따라 성능이 크게 달라질 수 있음)

/*
 * 해시 탐색의 주요 개념
    1. 해시 함수(Hash Function) :
        - 주어진 키를 고정된 크기의 정수 값으로 변환하는 함수(ex: "steve" -> 123456(유일한 값))
        - 이 정수 값을 해시 코드(hash code) 또는 해시 값(hash value)라고 함
        - 좋은 해시 함수는 입력 키의 고유성을 보존하면서 해시 테이블의 슬롯에 균등하게 분포되도록 한다.
 
    * 딕셔너리는 내부적으로 해시 함수를 사용하여 키를 고정된 크기의 해시 값(hash value)으로 변환함

    2. 해시 테이블(Hash Table) :
        - 해시 코드에 의해 인덱스화된 배열 형태의 자료구조
        - 각 슬롯이나 버킷은 하나 이상의 키-값 쌍을 저장 할 수 있다.

    * 딕셔너리의 내부적인 매커니즘은 HashTable을 만든다.(HashValue를 이용해서)
 
    3. 충돌(Conflict or Collision) :
        - 두 개 이상의 키가 동일한 해시 값을 가질 때 발생
        - 충돌 해결을 위한 여러가지 방법이 존재(개방 주소법, 체이닝)
 
    * 해시 충돌이 발생하는 이유?
        1. 해시 함수의 한계 :
            - 해시 함수는 임의 크기의 입력(Key)을 고정된 크기의 해시 값으로 매핑
            - 입력 공간(가능한 모든 Key)의 크기가 해시 값 공간보다 크기 때문에, 서로 다른 두 개의 입력이 동일한 해시 값을 가질 가능성(충돌)이 있음
        2. 키의 분포 :
            - 실제 사용하는 키들의 분포가 특정 패턴을 따를 경우, 해시 함수가 이러한 패턴을 균등하게 분포시키지 못한다면 충돌이 발생할 확률이 높아짐
 
    * 딕셔너리는 내부적으로 체이닝을 사용하여 충돌을 효율적으로 관리
 */


import Foundation

// K: Hashable한 타입(Swift 기본타입들은 Hashable)
class HashTable<K: Hashable, V> {
    private var table: [K: V] = [:] // 딕셔너리 사용
    
    // 삽입
    func insert(key: K, value: V) {
        table[key] = value
    }
    
    // 검색
    func search(key: K) -> V? {
        return table[key]
    }
    
    // 삭제
    func delete(key: K) {
        table.removeValue(forKey: key)
    }
}


/*
 * 슬롯 (Slot)
    - 슬롯은 해시 테이블의 배열에서 하나의 인덱스 위치를 의미
    - 각 슬롯은 일반적으로 하나의 키-값 쌍을 저장
    - 그러나 충돌 해결 방법에 따라 슬롯이 여러 개의 키-값 쌍을 저장할 수도 있음(예를 들어, 개방 주소법(Open Addressing)을 사용할 때는 충돌이 발생하면 다른 빈 슬롯을 찾아서 저장)
 
 * 버킷 (Bucket)
    - 버킷은 해시 테이블의 배열에서 하나의 인덱스 위치를 의미하지만, 보통 연결 리스트나 다른 구조로 구현되어 하나 이상의 키-값 쌍을 저장할 수 있음
    - 체이닝(Chaining) 방법을 사용할 때 주로 사용
    - 버킷은 충돌이 발생했을 때 해당 인덱스에 속하는 모든 키-값 쌍을 저장하는 공간
    - 각 버킷은 리스트, 트리, 혹은 다른 자료 구조로 구현될 수 있음
 
 * 충돌 해결 예시
 1. 개방 주소법 (Open Addressing):
    *충돌이 발생하면 다른 빈 슬롯을 찾아 저장하는 방법
    - 모든 키-값 쌍은 배열의 슬롯에 직접 저장
    - 충돌이 발생하면 다른 빈 슬롯을 찾아 저장
    - 예를 들어, 선형 탐사법(Linear Probing)에서는 다음 슬롯을 차례로 검사하여 빈 슬롯을 찾음
        1. 선형 탐사법 : 충돌이 발생하면 다음 슬롯을 차례로 탐색
        2. 이차 탐사법 : 충돌시 슬롯 인덱스를 이차 함수로 계산
        3. 이중 해싱 : 두 개의 해시 함수를 사용하여 충돌 해결

 2. 체이닝 (Chaining):
    * 각 슬롯을 연결 리스트로 만들어 동일한 슬롯에 속한 모든 요소를 저장하는 방법(충돌이 발생하면 해당 슬롯의 리스트에 새 요소를 추가함)
    - 각 버킷은 연결 리스트로 구현
    - 충돌이 발생하면 동일한 해시 값을 가진 키-값 쌍들을 해당 버킷의 리스트에 추가
    - 따라서 한 버킷에는 여러 개의 키-값 쌍이 저장될 수 있음
 */
