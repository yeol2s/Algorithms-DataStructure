//
//  ArrayDataStructure.swift
//  Algorithms
//
//  Created by 유성열 on 7/19/24.
//
// MARK: - 배열(Array)
// MARK: 데이터를 (Index 0부터)순서대로 저장(순서가 있음), 중복 값 저장 가능
// 순서가 있는 컬렉션, 같은 타입의 값을 저장하며 배열은 0부터 시작하는 인덱스를 가지고 인덱스를 통해 요소에 접근
// 한개의 배열에는 동일한 데이터 타입만 담을 수 있다.
// startIndex는 0, endIndex는 메모리 공간에 있는 인덱스의 끝의 값을 알려주므로 실제로는 endIndex - 1로 접근해야 마지막 요소에 접근 가능하다.
// 배열 비교시 저장 순서도 비교함(개별 요소 비교)

/*
 * 배열의 특징
    - 인덱스 기반 접근 : 배열은 내부적으로 연속된 메모리 블록을 사용하므로 배열은 인덱스를 사용하여 요소에 빠르게 접근 가능
    - 값의 순서가 보장(추가한 요소 순서대로)
    - 배열은 제네릭 타입(다양한 타입을 포함할 수 있음)
    - 크기 조정 : 배열은 동적으로 크기를 조정할 수 있음, 요소를 추가하거나 제거할 때 배열의 크기는 자동으로 조정된다.(일반적으로 상수 시간 O(1)의 복잡도를 가짐)
    - 고유 요소 보장하지 않음 : 배열은 중복된 요소를 허용하므로, 고유한 요소를 필요로 하는 경우 추가적인 처리가 필요
 
 * 배열의 장점 :
    - 빠른 접근 시간 : 배열은 인덱스를 기반으로 한 빠른 요소 접근이 가능(특정 위치의 요소에 대한 조회나 수정이 매우 빠름)(정렬된 배열은 비정렬 배열에 비해 검색 속도가 더 빠름)
    - 메모리 효율성 : 배열은 연속된 메모리 공간에 요소를 저장하므로, 메모리 캐시 효율성이 높다.
        * 배열은 연속된 메모리에 저장되지만, 요소가 추가되거나 제거될 때마다 항상 연속된 메모리에 저장되는 것이 보장되지는 않는다.
          배열은 요소가 추가될 때 마다 내부적으로 현재 크기와 필요한 크기를 비교하여 필요에 따라 크기를 조절하는데, 이 때 크기를 조정할 때마다 새로운 메모리 블록을 할당하고 기존 요소를 복사하는 경우가 일반적임
          이 과정에서 연속된 메모리 구조는 보존될 수 있지만 항상 보장되지 않는다. (메모리가 재할당되므로 이전 메모리 공간이 해제될 수 있으므로 새로 할당된 메모리 공간이 이전 공간과 물리적으로 연속된 것이 아닐 수 있다.)
        * 배열은 일반적으로 크기를 조정할 때 미리 여유 공간을 할당한다.(예를 들어, 요소를 추가할 때마다 일정 크기 이상의 여유 공간을 확보하여 새로운 요소를 추가하는 경우 추가적인 요소를 위해 새로운 메모리 공간을 할당하는 횟수를 줄 일 수 있음)
    - 다양한 활용 : 배열은 다양한 데이터 저장과 접근 패턴에 유용(데이터를 정렬하거나 필터링하는 등의 작업 수행)
 
 * 배열의 단점 :
    - 중간 삽입/삭제의 비효율성 : 배열은 특정 인덱스에 요소를 삽입하거나 삭제할 때, 그 위치 이후의 모든 요소를 이동시켜야 하는 경우가 발생함(평균적으로 O(n)의 시간 복잡도를 가지므로 많은 삽입/삭제 연산이 필요한 경우 성능이 저하됨)
    - 고정된 크기의 초기 할당 : 배열은 초기에 크기를 정해주지 않으면 작은 크기로 시작하여 요소를 추가할 때 마다 동적으로 크기를 조정하는데, 큰 배열을 초기에 생성할 경우 불필요한 메모리 사용 발생
    - 검색 시 성능 저하 가능성 : 배열은 인덱스 기반으로 접근이 빠르지만, 특정 요소를 검색하는 경우 배열 전체를 순회해야 할 수 있으므로 최악의 경우 O(n)의 시간 복잡도가 발생할 수 있다.
*/

import Foundation


