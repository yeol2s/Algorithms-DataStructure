//
//  DictionaryDataStructure.swift
//  Algorithms
//
//  Created by 유성열 on 7/22/24.
//
// MARK: - 딕셔너리(Dictionary)
// MARK: 데이터를 Key와 Value로 하나의 쌍으로 묶어서 관리(순서가 없음)
// 키값은 중복 불가능(해시테이블로 관리), 값은 중복 가능함
// 동일한 타입 쌍으로만 데이터를 담을 수 있다. -> [Int: String], [String: String]...
// 값에는 딕셔너리나 배열로 중첩 사용 가능하다. -> ["A": [1, 2, 3], "B": [1, 2, 3]]..
// 딕셔너리는 insert, replace, append 메서드 대신 update 메서드를 사용
// 딕셔너리의 키값은 Hashable(처리가 빠름) - 키값이 hash 함수 처리되어 HashValue(고유 번호)를 가지고 저장되는 것(HashTable로 관리)(Key는 Hashable 프로토콜을 준수해야 한다.)
// 서버와 통신하는 API는 대부분 딕셔너리 형태로 되어있음

/*
 * 딕셔너리의 특징
    - Key-Value 쌍으로 저장 : 각 항목은 고유한 키와 연관된 값으로 구성(Key는 Hashable 프로토콜을 준수해야 함)
    - 무작위 순서 : Key-Value 쌍을 무작위 순서로 저장(삽입 순서를 유지하지 않음)
    - 빠른 검색 : Key를 사용한 값의 검색은 매우 빠르며, 일반적으로 O(1)의 시간 복잡도를 가짐
    - 동적 크기 조정 : 딕셔너리는 필요에 따라 자동으로 크기를 조정(고정된 크기를 미리 지정할 필요 없음)
 
 * 딕셔너리의 장점 :
    - 빠른 데이터 접근 : (Hashable)Key를 통해 값에 빠르게 접근(대량의 데이터에서 특정 항목을 효율적으로 찾는 데 유용)
    - 유연한 데이터 저장 : 다양한 타입의 Key와 Value을 저장할 수 있어서 유연한 데이터 구조를 지원
    - 자동 중복 키 관리 : 같은 Key로 여러 값을 저장하려고 하면 기존 값이 새 값으로 자동 대체되므로 중복 Key 문제를 신경 쓸 필요가 없음
 
 * 딕셔너리의 단점 :
    - 메모리 사용량 : 딕셔너리는 내부적으로 HashTable을 사용하기 때문에, 다른 데이터 구조에 비해 메모리 사용량이 (상대적으로)높을 수 있음
    - 무작위 순서 : 삽입 순서가 보장되지 않음(순서가 중요하다면 딕셔너리는 적합하지 않음)
    - 느린 순회 : Array(배열)과 비교할 때 전체 요소를 순회하는 속도가 느릴 수 있음
    - 고유한 Key 필요 : Key는 고유해야 함(Key가 고유하지 않다면 딕셔너리 사용 불가)

*/

import Foundation

class DictionaryDataStructure {
    
    
    
    
}
